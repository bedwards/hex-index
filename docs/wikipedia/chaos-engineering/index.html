<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Chaos engineering - Hex Index</title>
  <link rel="stylesheet" href="../../styles.css">
</head>
<body class="reading-mode">
  <header class="reading-header">
    <a href="../../index.html" class="back-link">&larr; Back to Library</a>
  </header>
  <main class="reading-content">
    
    <article class="wikipedia-page">
      <header class="wikipedia-header">
        <div class="type-badge">Wikipedia Deep Dive</div>
        <h1>Chaos engineering</h1>
        <div class="article-meta">
          <span class="read-time">13 min read</span>
        </div>
      </header>

      <div class="wikipedia-content">
        <p class="source-note">Based on <a href="https://en.wikipedia.org/wiki/Chaos_engineering">Wikipedia: Chaos engineering</a></p>

<h2>The Art of Breaking Things on Purpose</h2>

<p>In 2011, Netflix engineers made a decision that would have gotten them fired at most companies. They built a program designed to randomly destroy their own production servers—the very computers keeping millions of customers streaming their favorite shows. They called it Chaos Monkey.</p>

<p>This wasn't sabotage. It was strategy.</p>

<p>Chaos engineering is the discipline of deliberately breaking your own systems to prove they can survive when things go wrong for real. It sounds counterintuitive, perhaps even reckless. But it rests on a profound insight: failures are inevitable, so you might as well choose when they happen.</p>

<h2>Why Break What Works?</h2>

<p>Modern software systems are bewilderingly complex. A single web application might depend on dozens of separate services, each running on multiple servers, all communicating across networks that can fail in countless ways. When you order a product online, your request might touch fifty different systems before the confirmation email lands in your inbox.</p>

<p>This complexity creates a fundamental problem. Engineers can reason about individual components, but predicting how all those pieces behave together—especially when something goes wrong—exceeds human intuition. The only way to truly understand how your system fails is to make it fail.</p>

<p>Traditional software testing asks: "Does this work correctly?" Chaos engineering asks a different question: "What happens when things stop working correctly?"</p>

<p>The distinction matters enormously. You can have perfect unit tests, flawless code reviews, and comprehensive quality assurance, yet still experience catastrophic outages because you never tested what happens when your database becomes unreachable for thirty seconds, or when one of your services starts responding ten times slower than usual.</p>

<h2>The Chaos Monkey Origin Story</h2>

<p>Netflix's migration to cloud computing in 2011 was the crucible that forged chaos engineering as a formal discipline. Engineers Nora Jones, Casey Rosenthal, and Greg Orzell faced a daunting challenge: how do you trust a system where the underlying hardware isn't yours, where servers can vanish without warning, where the infrastructure itself is fundamentally ephemeral?</p>

<p>Their answer was elegant and brutal. Instead of hoping servers wouldn't fail, they guaranteed servers would fail—frequently, randomly, during business hours when engineers were awake to observe the consequences.</p>

<p>Netflix's leadership articulated the philosophy in characteristically direct terms:</p>

<blockquote>At Netflix, our culture of freedom and responsibility led us not to force engineers to design their code in a specific way. Instead, we discovered that we could align our teams around the notion of infrastructure resilience by isolating the problems created by server neutralization and pushing them to the extreme. We have created Chaos Monkey, a program that randomly chooses a server and disables it during its usual hours of activity. Some will find that crazy, but we could not depend on the random occurrence of an event to test our behavior in the face of the very consequences of this event.</blockquote>

<p>The results transformed how Netflix engineers thought about reliability. When you know Chaos Monkey might terminate your server at any moment, you write code differently. You add redundancy. You automate recovery. You build systems that degrade gracefully rather than failing catastrophically.</p>

<p>Netflix released Chaos Monkey's source code in 2012 under an open-source license, allowing the entire industry to adopt the practice.</p>

<h2>A Surprisingly Ancient Idea</h2>

<p>Although Netflix popularized chaos engineering and gave it a name, the core concept predates the cloud era by decades. The history reveals something interesting: engineers independently discover this approach whenever they're building systems too complex to test through conventional means.</p>

<p>In 1983, while developing MacWrite and MacPaint for the original Macintosh computer, Apple engineer Steve Capps created something he called "Monkey." It was a small program that generated random user interface events at frantic speed—mouse clicks, keyboard presses, window movements—simulating a monkey frantically bashing away at the computer.</p>

<p>The first Macintosh had so little memory that sophisticated automated testing was impossible. But Monkey could run for hours, randomly exercising the software in ways no human tester would think to try. It found bugs that careful manual testing missed.</p>

<p>Nearly a decade later, in 1992, Iain James Marshall created a similar tool called "La Matraque" (French for "the baton" or "the club") for the PROLOGUE operating system. La Matraque generated random sequences of both valid and invalid graphical interface commands, running for days at a time to stress-test the underlying graphics libraries before production releases.</p>

<p>The pattern repeats throughout computing history. Whenever systems grow complex enough, someone invents a way to attack them randomly as a testing strategy.</p>

<h2>Game Days and Disaster Rehearsals</h2>

<p>Chaos Monkey represents one flavor of chaos engineering: automated, continuous, small-scale failures. But there's another approach that's equally valuable—the deliberate, planned catastrophe.</p>

<p>At Amazon in 2003, Jesse Robbins created "Game Day," a practice of intentionally triggering major system failures on a regular schedule. Robbins drew inspiration from an unexpected source: firefighter training. Fire departments don't wait for actual fires to practice. They conduct drills, simulate emergencies, and rehearse their responses until the actions become muscle memory.</p>

<p>Game Day applies the same principle to software systems. Once a quarter, or once a month, Amazon's engineers would deliberately break something significant—disable an entire service, simulate a data center going offline, kill a critical database. Then they'd observe how their systems responded and how their teams reacted.</p>

<p>Google developed a similar program called DiRT, which stands for Disaster Recovery Testing. The name captures the philosophy perfectly. Disaster recovery isn't something you read about in a document. It's something you practice, repeatedly, until you're confident you can execute it when the real disaster strikes at three in the morning.</p>

<p>The difference between Game Day-style testing and Chaos Monkey is like the difference between fire drills and smoke detectors. You need both. Automated chaos catches regressions and keeps engineers honest about redundancy. Planned chaos events test your team's ability to coordinate under pressure and validate that your disaster recovery procedures actually work.</p>

<h2>The Simian Army</h2>

<p>Netflix's Chaos Monkey proved so valuable that it spawned an entire family of chaos-inducing tools, collectively known as the Simian Army. Each "simian" targets a different type of failure at a different scale.</p>

<p>Chaos Gorilla takes the concept up several notches. While Chaos Monkey terminates individual servers, Chaos Gorilla disables an entire Amazon Web Services Availability Zone—which is to say, one or more complete data centers serving a geographic region. If your application survives Chaos Gorilla, it can handle the loss of an entire data center without your customers noticing.</p>

<p>Chaos Kong goes further still, simulating the loss of an entire AWS Region. This is the ultimate test: can your application keep running if every server in, say, the eastern United States simultaneously becomes unavailable? Regional failures are rare but not unheard of, and companies that operate at global scale must be prepared for them.</p>

<p>A memorable passage from Antonio Garcia Martinez's book <em>Chaos Monkeys</em> offers a vivid metaphor for this entire approach:</p>

<blockquote>Imagine a monkey entering a 'data center', these 'farms' of servers that host all the critical functions of our online activities. The monkey randomly rips cables, destroys devices and returns everything that passes by the hand. The challenge for IT managers is to design the information system they are responsible for so that it can work despite these monkeys, which no one ever knows when they arrive and what they will destroy.</blockquote>

<h2>The Broader Discipline</h2>

<p>Chaos engineering has evolved well beyond Netflix's original tools. The approach now encompasses three broad categories of intentional failure.</p>

<p><strong>Infrastructure failures</strong> test what happens when the underlying hardware or cloud services malfunction. This includes server crashes, disk failures, memory exhaustion, and the sudden loss of computing resources.</p>

<p><strong>Network failures</strong> simulate the myriad ways that communication between services can break down. Networks can become completely unreachable, experience severe delays, drop packets randomly, or partition in ways that leave some services able to communicate with each other while others are isolated.</p>

<p><strong>Application failures</strong> inject problems at the software level—exceptions in critical code paths, resource leaks, deadlocks, and the cascading effects of dependency failures.</p>

<p>Modern chaos engineering platforms like Gremlin, Steadybit, and others offer "failure as a service," allowing companies to inject precisely controlled chaos into their systems without building all the tooling themselves. You can specify exactly which failures to simulate, how long they should last, and what percentage of traffic or servers they should affect.</p>

<h2>Measuring Resilience</h2>

<p>Breaking things is only useful if you can measure the results. Chaos engineering produces valuable data about system behavior under stress, but you need metrics to make sense of that data.</p>

<p>A 2022 study at IBM examined chaos engineering in Kubernetes environments—Kubernetes being the container orchestration platform that has become the standard for deploying modern applications. Researchers terminated random pods (the smallest deployable units in Kubernetes) that were receiving data from edge devices and processing analytics.</p>

<p>The key metric they tracked was pod recovery time: how quickly could the system detect that a pod had died and bring up a replacement? This single number encapsulates much of what matters about resilience. A system that recovers in milliseconds will be imperceptibly affected by failures. A system that takes minutes to recover may leave users frustrated or transactions lost.</p>

<p>Operational readiness—the confidence that a system is prepared for production conditions—can be quantified through chaos engineering simulations. You might measure recovery time, error rates during failures, the percentage of requests that succeed despite ongoing chaos, or the mean time between user-visible incidents.</p>

<h2>Phoenix Servers and Disposable Infrastructure</h2>

<p>Chaos engineering connects to a broader shift in how we think about infrastructure. The traditional approach treated servers as precious, long-lived entities to be carefully maintained and nursed back to health when problems arose. The modern approach, articulated by technology author Martin Fowler in 2012, proposes treating servers as "Phoenix Servers"—systems designed to be destroyed and recreated from scratch.</p>

<p>The name comes from the mythological bird that dies in flames and is reborn from its own ashes. A Phoenix Server can be terminated at any moment because an identical replacement can be spun up automatically. There's no unique state, no careful accumulation of patches and configurations, no irreplaceable machine.</p>

<p>Chaos engineering and Phoenix Servers reinforce each other. If your servers are designed to be disposable, you can terminate them without fear. And if you're routinely terminating servers through chaos engineering, you'll naturally evolve toward architectures where servers are disposable.</p>

<h2>The Cultural Transformation</h2>

<p>Perhaps the most significant impact of chaos engineering isn't technical at all. It's cultural.</p>

<p>In organizations that practice chaos engineering, resilience becomes every engineer's responsibility. You can't write code that only works when everything goes well, because Chaos Monkey will prove you wrong. You can't skip building recovery mechanisms, because Game Day will expose the gap.</p>

<p>Netflix's original insight bears repeating: they couldn't force engineers to write resilient code, but they could create an environment where non-resilient code was immediately and obviously broken. By pushing failure "to the extreme," they aligned every team around the goal of building systems that could survive.</p>

<p>This represents a profound shift from hoping that failures won't happen to accepting that failures are inevitable and engineering for them explicitly. It's the difference between crossing your fingers and buying insurance—and then testing whether the insurance actually pays out.</p>

<h2>Practicing Chaos Safely</h2>

<p>All of this might sound dangerous, and it can be if done carelessly. Chaos engineering requires safeguards.</p>

<p>Start small. Begin with the smallest possible experiment that could reveal useful information. Terminate a single server in a test environment before you move to production. Simulate a network delay before you simulate a complete network partition.</p>

<p>Define your steady state. Before introducing chaos, you need to know what "normal" looks like. What are your baseline error rates? How quickly do requests typically complete? You can only measure the impact of chaos if you have a clear picture of the system without chaos.</p>

<p>Minimize the blast radius. Modern chaos engineering tools allow you to limit experiments to a small percentage of traffic or a specific subset of servers. If something goes terribly wrong, the damage is contained.</p>

<p>Have a hypothesis. Don't just break things randomly. Each chaos experiment should test a specific belief about how your system will behave. "We believe that if Server A fails, Server B will take over within 100 milliseconds." The experiment either confirms or refutes this hypothesis.</p>

<p>Build a kill switch. Every chaos experiment should be immediately reversible. If you start seeing unexpected failures or customer impact, you need to be able to stop the experiment instantly.</p>

<h2>The Opposite of Chaos Engineering</h2>

<p>To truly understand chaos engineering, it helps to consider its opposite: what happens when you don't practice it.</p>

<p>The alternative is waiting for real failures to teach you about your system's weaknesses. This approach has several problems. Real failures happen at inconvenient times—during peak traffic, during holidays, at three in the morning. Real failures affect real customers, damaging trust and potentially revenue. Real failures are uncontrolled, potentially cascading in ways that dwarf the original problem.</p>

<p>The first time you discover that your database failover doesn't actually work shouldn't be during a production outage. The first time you learn that your backup restoration takes eight hours shouldn't be when you're desperately trying to recover from data loss. Chaos engineering lets you make these discoveries safely, on your own schedule, with engineers watching and learning.</p>

<h2>Beyond the Server Room</h2>

<p>The principles of chaos engineering extend beyond software systems. Any complex system benefits from controlled testing of its failure modes.</p>

<p>Hospitals conduct mock disasters to test their emergency procedures. Airlines run simulations where pilots must handle unlikely but possible equipment failures. The military conducts war games. Financial institutions run stress tests.</p>

<p>In each case, the logic is the same: better to discover problems during a rehearsal than during the real event. Better to build confidence through controlled experiments than through hopeful assumptions.</p>

<p>Facebook developed Project Storm specifically to test how their data centers would respond to natural disasters. By simulating the effects of hurricanes, earthquakes, and other catastrophes, they could verify that their systems would keep running—or identify gaps to address before disaster struck.</p>

<h2>The Confidence Equation</h2>

<p>At its heart, chaos engineering is about confidence. Not false confidence, the kind that comes from assuming everything will work. Real confidence, the kind that comes from knowing you've tested your assumptions.</p>

<p>Every chaos experiment that your system survives is evidence that your resilience mechanisms work. Every experiment that reveals a weakness is an opportunity to strengthen your system before that weakness matters. Either outcome is valuable.</p>

<p>The goal isn't to prove your system is perfect. It's to build justified confidence in your system's ability to withstand turbulent conditions. That confidence lets you sleep soundly, ship faster, and serve your users better.</p>

<p>As software continues to eat the world, chaos engineering becomes increasingly essential. The systems we depend on—for communication, for commerce, for critical infrastructure—must be resilient. And the only way to be sure they're resilient is to test them, regularly and rigorously, under conditions that simulate the chaos of the real world.</p>

<p>The monkey is going to get into the data center eventually. The question is whether you've prepared for its arrival.</p>
      </div>

      <footer class="wikipedia-footer">
        <p class="source-link">
          <a href="https://en.wikipedia.org/wiki/Chaos_engineering" target="_blank" rel="noopener">
            View original Wikipedia article &rarr;
          </a>
        </p>
        <p class="rewrite-note">
          This article has been rewritten from Wikipedia source material for enjoyable reading.
          Content may have been condensed, restructured, or simplified.
        </p>
      </footer>

      
      <section class="related-articles">
        <h2>Related Articles</h2>
        <p class="related-intro">This deep dive was written in connection with these articles:</p>
        <ul class="related-list">
          
      <li class="related-article-item">
        <a href="../../article/1c3061fa-4642-4bf2-9663-34b9587fe76c/index.html">
          <strong>How Shopify Prepares for Black Friday</strong>
        </a>
        <span class="article-meta">
          by Alex Xu in ByteByteGo Newsletter
        </span>
      </li>

      <li class="related-article-item">
        <a href="../../article/e8d357b3-9d7c-4e85-be8c-1c2fc78f812a/index.html">
          <strong>The Pulse #156: Beware of global configuration changes in large systems</strong>
        </a>
        <span class="article-meta">
          by Gergely Orosz in The Pragmatic Engineer
        </span>
      </li>

      <li class="related-article-item">
        <a href="../../article/f3120661-a8b9-4e9d-89a6-cc229a462a6f/index.html">
          <strong>Netflix’s Engineering Culture</strong>
        </a>
        <span class="article-meta">
          by Gergely Orosz in The Pragmatic Engineer
        </span>
      </li>
        </ul>
      </section>
    
    </article>
  
  </main>
</body>
</html>
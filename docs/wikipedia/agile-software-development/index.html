<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Agile software development - Hex Index</title>
  <link rel="stylesheet" href="../../styles.css">
</head>
<body class="reading-mode">
  <header class="reading-header">
    <a href="../../index.html" class="back-link">&larr; Back to Library</a>
  </header>
  <main class="reading-content">
    
    <article class="wikipedia-page">
      <header class="wikipedia-header">
        <div class="type-badge">Wikipedia Deep Dive</div>
        <h1>Agile software development</h1>
        <div class="article-meta">
          <span class="read-time">14 min read</span>
        </div>
      </header>

      <div class="wikipedia-content">
        <p class="source-note">Based on <a href="https://en.wikipedia.org/wiki/Agile_software_development">Wikipedia: Agile software development</a></p>

<h2>The Snowbird Rebellion</h2>

<p>In February 2001, seventeen programmers escaped to a ski resort in Snowbird, Utah. They weren't there to ski. They were there to start a revolution.</p>

<p>These weren't random developers. They were the architects of competing methodologies—people who had spent years building rival systems for how software should be made. Kent Beck had created Extreme Programming. Jeff Sutherland and Ken Schwaber had developed Scrum. Alistair Cockburn had designed Crystal. They were, in a sense, competitors. But they shared a common enemy: the crushing bureaucracy that had come to dominate software development.</p>

<p>What they produced in that Utah lodge would reshape an entire industry. They called it the Manifesto for Agile Software Development.</p>

<h2>What They Were Fighting Against</h2>

<p>To understand agile, you first need to understand what came before it. The dominant approach to building software in the 1990s was called the "waterfall" method, though that name was often used as an insult by its critics.</p>

<p>Waterfall worked like this: First, you gathered every requirement. All of them. You wrote them down in enormous specification documents—sometimes hundreds of pages. Then, and only then, did you start designing the system. After design came implementation. After implementation came testing. Each phase flowed into the next, like water cascading down a series of steps. Hence the name.</p>

<p>The appeal was obvious. Waterfall promised predictability. Managers could plan. Budgets could be set. Deadlines could be estimated with apparent precision.</p>

<p>The reality was something else entirely.</p>

<p>By the time a waterfall project reached the testing phase—often months or years after the original requirements were written—the world had changed. The business had evolved. Competitors had launched new products. What users wanted had shifted. But the specifications were locked. The plan was the plan. And so teams delivered software that was technically correct according to documents written in a world that no longer existed.</p>

<p>Critics described these processes as "heavyweight"—overly regulated, obsessively planned, and suffocatingly micromanaged. The documentation itself became a kind of theater, with teams producing elaborate tomes that nobody read, maintained, or used. The process existed to serve the process, not the product.</p>

<h2>The Manifesto's Core Insight</h2>

<p>The Snowbird manifesto fit on a single page. It had to. The whole point was simplicity.</p>

<p>The seventeen authors declared that they valued:</p>

<ul>
<li>Individuals and interactions over processes and tools</li>
<li>Working software over comprehensive documentation</li>
<li>Customer collaboration over contract negotiation</li>
<li>Responding to change over following a plan</li>
</ul>

<p>Notice the careful phrasing. They didn't say processes and tools were worthless. They didn't say documentation was pointless. They said that when forced to choose—when trade-offs had to be made—they would prioritize the items on the left over those on the right.</p>

<p>This wasn't nihilism. It was pragmatism.</p>

<p>Jim Highsmith, one of the manifesto's authors, later clarified what they were trying to accomplish:</p>

<blockquote>"The Agile movement is not anti-methodology, in fact many of us want to restore credibility to the word methodology. We want to restore a balance. We embrace modeling, but not in order to file some diagram in a dusty corporate repository. We embrace documentation, but not hundreds of pages of never-maintained and rarely-used tomes. We plan, but recognize the limits of planning in a turbulent environment."</blockquote>

<p>The manifesto's genius was recognizing that software development is fundamentally an exercise in uncertainty. Requirements change. Users don't know what they want until they see what they don't want. Markets shift. Technologies evolve. Any methodology that pretends otherwise is building on sand.</p>

<h2>The Twelve Principles</h2>

<p>Behind the manifesto's four values lay twelve principles that spelled out what agile development actually looked like in practice. Some were specific. Some were philosophical. All were designed to flip the old assumptions on their head.</p>

<p>The first principle was about delivering value early and often: satisfy customers through continuous delivery of valuable software. Don't make them wait years for a big reveal. Give them something useful now, then make it better.</p>

<p>The second principle embraced what waterfall feared most: welcome changing requirements, even late in development. Traditional thinking treated late changes as failures of planning. Agile reframed them as opportunities to deliver something better.</p>

<p>Working software should ship frequently—weeks rather than months. Business people and developers should work together daily, not pass documents through intermediaries. Projects should be built around motivated individuals who are trusted to get the job done.</p>

<p>Face-to-face conversation beats email and memos. Working software is the primary measure of progress—not documents written, meetings held, or boxes checked. Development should be sustainable; teams shouldn't burn out sprinting to arbitrary deadlines.</p>

<p>Technical excellence and good design require continuous attention. Simplicity—defined beautifully as "the art of maximizing the amount of work not done"—is essential. The best architectures and designs emerge from self-organizing teams, not top-down mandates.</p>

<p>And finally, teams should regularly reflect on how to become more effective, then adjust accordingly.</p>

<h2>How Agile Actually Works</h2>

<p>The manifesto was philosophy. The various methodologies that aligned with it—Scrum, Extreme Programming, Crystal, and others—were the practical implementations.</p>

<p>Despite their differences, most agile methods share a common structure. They break work into small increments called iterations or sprints, typically lasting one to four weeks. Each iteration is a complete cycle: planning, designing, coding, testing, and demonstrating working software to stakeholders.</p>

<p>The key phrase there is "working software." At the end of each sprint, you don't have a progress report or an updated Gantt chart. You have actual code that does actual things that actual users can try.</p>

<p>This approach flips the traditional risk profile of software development. In waterfall, you accumulate risk throughout the project. You don't know if your design works until you try to build it. You don't know if your code works until you test it. You don't know if your product works until users see it. All that uncertainty compounds, and it all comes due at the end.</p>

<p>Agile frontloads the learning. Every two weeks, you discover what works and what doesn't. The phrase practitioners use is "fail often and early." If something is going wrong, you find out in week three, not month eighteen.</p>

<h2>The Daily Stand-up</h2>

<p>Perhaps no agile practice has become more iconic—or more frequently mocked—than the daily stand-up meeting.</p>

<p>The concept is simple. Every day, the team gathers briefly. Fifteen minutes maximum. People literally stand, partly to emphasize brevity and partly because sitting encourages lingering. Each person answers three questions: What did I accomplish yesterday? What will I work on today? Is anything blocking my progress?</p>

<p>That's it. No status presentations. No PowerPoint slides. No detailed discussions of technical approaches. Those happen elsewhere. The stand-up exists solely to synchronize the team and surface problems quickly.</p>

<p>When done well, stand-ups create a rhythm. They ensure that nobody disappears into a corner for days, only to emerge with something that doesn't integrate with everyone else's work. They catch blockers before they metastasize into delays.</p>

<p>When done poorly—which happens constantly—they become exactly the kind of bureaucratic ritual that agile was designed to eliminate. Teams that don't understand the purpose turn them into status reports for managers, or let them bloat into hour-long discussions, or treat them as obligations rather than tools.</p>

<h2>The Customer in the Room</h2>

<p>One of agile's more radical ideas is that every development team should include a customer representative—someone who can speak for what users actually need.</p>

<p>In Scrum, this person is called the product owner. Their job is to be available. When developers have questions, the product owner answers them. When trade-offs need to be made, the product owner makes them. When priorities need to shift, the product owner decides.</p>

<p>This sounds obvious until you consider how software was traditionally built. Business people would write requirements, throw them over a wall to developers, and disappear until delivery date. Questions accumulated. Assumptions multiplied. By the time anyone checked whether the product met actual needs, months had passed.</p>

<p>Agile insists on continuous feedback. At the end of every iteration, stakeholders review what's been built. They see working software, not wireframes or mockups. They use it. They react. And their reactions shape what gets built next.</p>

<p>This is why agile is sometimes called a customer-centered methodology. The customer isn't someone who shows up at the beginning and end. They're embedded in the process throughout.</p>

<h2>The Information Radiator</h2>

<p>Walk into an agile team's workspace—at least, a traditional one—and you'll likely see something called an information radiator. It's exactly what it sounds like: a large, prominent display that broadcasts the project's status to anyone who walks by.</p>

<p>The classic version is a physical board covered with sticky notes. Each note represents a task. Columns represent stages: to do, in progress, done. Anyone can glance at the board and immediately understand what's happening.</p>

<p>The term "radiator" is deliberate. The information doesn't require active retrieval. You don't have to ask someone for a status update or request access to a project management tool. The information radiates outward, available to anyone who cares to look.</p>

<p>Some teams add build lights—actual physical lights that glow green when the software is healthy and red when something's broken. The point, again, is immediacy. Problems shouldn't hide in dashboards that nobody checks. They should be impossible to ignore.</p>

<h2>The Prehistory of Agile</h2>

<p>Though the Agile Manifesto was published in 2001, the ideas behind it had been percolating for decades. Iterative and incremental development—building software in small pieces rather than all at once—can be traced back to at least 1957.</p>

<p>The various lightweight methodologies that the Snowbird attendees had developed were themselves reactions to earlier reactions. Rapid Application Development emerged in 1991. The Unified Process and Dynamic Systems Development Method appeared in 1994. Scrum followed in 1995. Extreme Programming and Crystal Clear came in 1996. Feature-Driven Development arrived in 1997.</p>

<p>All of these predated the manifesto. What Snowbird accomplished wasn't invention—it was unification. It gave these disparate approaches a common identity and a shared vocabulary. Before 2001, practitioners of these methods were scattered tribes. After 2001, they were a movement.</p>

<p>The manufacturing world had arrived at similar conclusions even earlier. Lean management, which influenced many agile ideas, emerged from Toyota's production system in the decades after World War II. The core insight—eliminate waste, empower workers, iterate continuously—translated surprisingly well from factory floors to software development.</p>

<h2>Adaptive Versus Predictive</h2>

<p>Development methodologies exist on a spectrum. On one end sits the purely predictive approach: analyze everything upfront, plan everything in detail, then execute the plan. On the other end sits the purely adaptive approach: start building, learn as you go, adjust continuously.</p>

<p>Agile methods cluster toward the adaptive end, but they're not anarchic. They still plan. They still analyze. They just accept that early plans are educated guesses, and they build in mechanisms to update those guesses as reality reveals itself.</p>

<p>The practical difference shows up in how teams talk about the future. Ask a predictive team what they'll deliver in six months, and they'll show you a detailed roadmap. Every feature specified. Every milestone scheduled. Ask an adaptive team the same question, and you'll get something vaguer—a mission statement, perhaps, or a general direction. They can tell you what they're building next sprint. They can sketch what they're aiming for next month. But six months out? That's too far away to predict with confidence.</p>

<p>Neither approach is universally superior. Predictive methods work well when requirements are stable and well-understood—when you're building something that's been built before, with known technology and clear specifications. Adaptive methods excel when requirements are uncertain, when technology is evolving, when you're solving a new problem.</p>

<p>The challenge is recognizing which situation you're actually in. Many projects that seem predictable turn out to be anything but.</p>

<h2>Quality as a Feature, Not a Phase</h2>

<p>One of the starkest differences between agile and traditional development is how they treat quality.</p>

<p>In waterfall, testing is a phase. You build the software, then you test it. Quality assurance is something that happens after development, performed by a separate team, often in a separate location.</p>

<p>In agile, testing happens continuously. The same iteration that produces code also produces tests. Developers and testers work together—sometimes they're the same people. Quality isn't inspected in at the end; it's built in from the beginning.</p>

<p>This approach enables practices like test-driven development, where programmers write tests before writing code. It sounds counterintuitive—how can you test something that doesn't exist yet?—but the discipline forces clarity. Before you build something, you have to define what "working" means. The tests become executable specifications.</p>

<p>Continuous integration takes this further. Every time a developer makes a change, automated systems compile the code, run the tests, and verify that nothing broke. Problems get caught in minutes, not months. The build light stays green.</p>

<h2>The Criticism</h2>

<p>Not everyone was converted. Steven Rakitin, writing in IEEE Computer, dismissed agile as "yet another attempt to undermine the discipline of software engineering."</p>

<p>The criticism isn't entirely unfair. Agile can be poorly implemented. Some organizations adopt the vocabulary without the substance—they do daily stand-ups and call their work periods "sprints," but they haven't actually changed how they make decisions or respond to change. They've added agile rituals to waterfall processes, getting the worst of both worlds.</p>

<p>The empirical evidence on agile's effectiveness is also thinner than advocates sometimes admit. Plenty of anecdotes suggest it works. Success stories abound. But controlled studies comparing agile to alternative approaches are limited and less conclusive than the manifestos might suggest.</p>

<p>And agile makes promises that are genuinely hard to keep. Responding to change sounds good until you're the one explaining to stakeholders why the roadmap shifted again. Customer collaboration is wonderful in theory, but finding a customer representative who's actually available, empowered, and knowledgeable is remarkably difficult. Self-organizing teams require trust that many organizations aren't prepared to extend.</p>

<h2>The Evolution Continues</h2>

<p>The Agile Manifesto was just the beginning. In 2005, a group led by Alistair Cockburn and Jim Highsmith produced the PM Declaration of Interdependence, adapting agile principles specifically for project management. In 2009, another group working with Robert Martin created the Software Craftsmanship Manifesto, emphasizing professional conduct and mastery.</p>

<p>The Agile Alliance itself has continued evolving. In 2011, they created a guide to agile practices—later renamed the Agile Glossary—that serves as a living reference for the community.</p>

<p>Perhaps the biggest change since 2001 has been the rise of remote work. The manifesto's sixth principle praised face-to-face conversation as the most efficient communication method. That was written before video conferencing was ubiquitous. The COVID-19 pandemic forced a massive experiment in distributed agile, and the results have been more nuanced than purists predicted. Co-location helps, but it's not essential. The tools have improved. The practices have adapted.</p>

<p>Which, in a way, proves the manifesto's point. Agile isn't a rigid methodology. It's a mindset—one that expects the world to change and plans accordingly.</p>

<h2>The Legacy of Snowbird</h2>

<p>Over two decades after seventeen developers gathered at a ski resort, agile has become the dominant paradigm in software development. Most technology companies describe their processes as agile, whether or not they actually follow its principles. The terminology has seeped into general business culture; non-software teams now talk about sprints and stand-ups.</p>

<p>Success has brought its own problems. Agile has been commercialized, certified, and occasionally corrupted. Consultants sell expensive transformations. Certification bodies award badges. What began as a rebellion against bureaucracy has sometimes become a new form of bureaucracy, complete with its own jargon, rituals, and gatekeepers.</p>

<p>But the core insight remains valuable. Software development is uncertain. Plans change. Users don't know what they want. The only way to discover what works is to build something, show it to people, and learn from their reactions. Then do it again. And again. And again.</p>

<p>That's the real manifesto: embrace uncertainty, ship frequently, learn continuously. Everything else is implementation details.</p>
      </div>

      <footer class="wikipedia-footer">
        <p class="source-link">
          <a href="https://en.wikipedia.org/wiki/Agile_software_development" target="_blank" rel="noopener">
            View original Wikipedia article &rarr;
          </a>
        </p>
        <p class="rewrite-note">
          This article has been rewritten from Wikipedia source material for enjoyable reading.
          Content may have been condensed, restructured, or simplified.
        </p>
      </footer>

      
      <section class="related-articles">
        <h2>Related Articles</h2>
        <p class="related-intro">This deep dive was written in connection with these articles:</p>
        <ul class="related-list">
          
      <li class="related-article-item">
        <a href="../../article/57f6892d-61b5-4cc0-9f44-272ddc606f75/index.html">
          <strong>How AI will change software engineering – with Martin Fowler</strong>
        </a>
        <span class="article-meta">
          by Gergely Orosz in The Pragmatic Engineer
        </span>
      </li>
        </ul>
      </section>
    
    </article>
  
  </main>
</body>
</html>